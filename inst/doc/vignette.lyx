#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{natbib}
\usepackage{url}
\usepackage{tikz}
\usetikzlibrary{matrix}
\end_preamble
\use_default_options true
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\boxbgcolor #dbdbdb
\branch answer
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\rightmargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Introduction to 
\series bold
RcppSimpleTensor
\end_layout

\begin_layout Author
Thibaut Lamadon and Florian Oswald
\begin_inset Newline newline
\end_inset


\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/tlamadon/RcppSimpleTensor
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
SweaveOpts{fig.path=figure/,fig.align=center,fig.show=hold}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<setup,echo=FALSE,results=hide,message=FALSE>>=
\end_layout

\begin_layout Plain Layout

options(replace.assign=TRUE)
\end_layout

\begin_layout Plain Layout

knit_hooks$set(par=function(before, options, envir){if (before) par(mar=c(4,4,.1,.
1),cex.lab=.95,cex.axis=.9,mgp=c(2,.7,0),tcl=-.3,las=1)})
\end_layout

\begin_layout Plain Layout

library(ggplot2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In this vignette we will introduce the 
\series bold
RcppSimpleTensor 
\series default
package by some examples.
 For information regarding installation, please refer to the website (above).
 Will first demonstrate usage with the help of a very simple example that
 permits a graphical representation.
 Then we will present an application that uses RcppSimpleTensor, where we
 want to find an approximatin to the integral of a multivariate function.
 
\end_layout

\begin_layout Section
Usage
\end_layout

\begin_layout Standard
Tensor algebra is a convenient way to deal with high-dimensional objects.
 In a way, it is like matrix multiplication for arrays of general dimension
 N-D.
 Note, however, that the operations one can perform are not restricted to
 be matrix multiplication only, but any kind of mathematical operation 
\emph on
along a given index
\emph default
 of an array.
 In this section we demonstrate some ways to use the library by operating
 on three arrays 
\family typewriter
a
\family default
, 
\family typewriter
b
\family default
 and 
\family typewriter
B
\family default
, defined as follows:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<usage-data>>=
\end_layout

\begin_layout Plain Layout

a <- array(1:8,dim=c(2,2,2)) 
\end_layout

\begin_layout Plain Layout

b <- array(1,dim=c(2,1)) 
\end_layout

\begin_layout Plain Layout

B <- array(1,dim=c(2,2)) 
\end_layout

\begin_layout Plain Layout

print(a)
\end_layout

\begin_layout Plain Layout

print(b)
\end_layout

\begin_layout Plain Layout

print(B)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Multidimensional Multiplication
\end_layout

\begin_layout Standard
We will use the two main functions in RcppSimpleTensor, tensorFunction and
 TI, to show different forms of matrix multiplication.
 The two functions perform the same tasks, the difference is that TI is
 for inline use, and tensorFunction needs to be defined before usage.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
tibo: you should here (or at some point) explain this difference a bit better.
 in particular the issue of being able to call tensorFunction from within
 an evironment where it was not defined.
 (?)
\end_layout

\end_inset

First of all, notice that array a can be visualized as a cube (see figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-array-a"

\end_inset

).
 
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

[back line/.style={densely dotted},cross line/.style={preaction={draw=white,
 -,line width=6pt}}] 
\end_layout

\begin_layout Plain Layout


\backslash
matrix (m) [matrix of math nodes,row sep=3em, column sep=5em,text height=1.5ex,te
xt depth=0.25ex]{& 5  & & 7 
\backslash

\backslash
 1 & & 3 
\backslash

\backslash
 & 6 & & 8 
\backslash

\backslash
 2 & & 4 
\backslash

\backslash
 }; 
\end_layout

\begin_layout Plain Layout


\backslash
path[-] (m-1-2) edge (m-1-4) edge (m-2-1) edge [back line] (m-3-2) (m-1-4)
 edge (m-3-4) edge (m-2-3) (m-2-1) edge [cross line] (m-2-3) edge (m-4-1)
 (m-3-2) edge [back line] (m-3-4) edge [back line] (m-4-1) (m-4-1) edge
 (m-4-3) (m-3-4) edge (m-4-3) (m-2-3) edge [cross line] (m-4-3); 
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The array 
\family typewriter
a
\begin_inset CommandInset label
LatexCommand label
name "fig:The-array-a"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 We will now perform operations along the 3 different indices of this array,
 and we will denote those indices i (vertical direction), j (horizontal
 direction) and k (in-depth direction).
 All of our examples are a form of tensor reduction, i.e.
 we operate along a certain dimension of an array to reduce the array in
 this dimension.
 In terms of figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-array-a"

\end_inset

, we would flatten the cube along a certain index, applying a certain operation
 to the elements.
 Needless to say, the gains from using RcppSimpleTensor get larger as the
 dimension of a grows, but we will go with this easy example for illustration.
\end_layout

\begin_layout Subsubsection
Matrix multiply a with b along index i
\end_layout

\begin_layout Standard
As a first task, we want to multiply a with vector b along their common
 index i, that is along the vertical direction of a.
 This means our result will still have indices j and k, as we only 
\begin_inset Quotes eld
\end_inset

flattened-out
\begin_inset Quotes erd
\end_inset

 a along dimension i:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<usage1,message=FALSE>>=
\end_layout

\begin_layout Plain Layout

library(RcppSimpleTensor)
\end_layout

\begin_layout Plain Layout

# 1.
 define tensor function
\end_layout

\begin_layout Plain Layout

tensFunc <- tensorFunction( R[k,j] ~ a[i,j,k] * b[i] )
\end_layout

\begin_layout Plain Layout

# 2.
 and call it
\end_layout

\begin_layout Plain Layout

y <- tensFunc( a, b)
\end_layout

\begin_layout Plain Layout

y
\end_layout

\begin_layout Plain Layout

# or define the tensor inline with TI()
\end_layout

\begin_layout Plain Layout

y <- TI( a[i,j,k] * b[i], k + j)
\end_layout

\begin_layout Plain Layout

y
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice that this is like looking at the cube from above and performing the
 operation a[ ,j,k] * b at each pair of coordinates (j,k).
 If we let 
\begin_inset Formula $y_{i,j}$
\end_inset

 be the element in row 
\begin_inset Formula $i$
\end_inset

, column 
\begin_inset Formula $j$
\end_inset

, we obtained 
\begin_inset Formula 
\begin{eqnarray*}
y_{1,1} & = & a_{1,1,1}b_{1}+a_{2,1,1}b_{2}=1\cdot1+2\cdot1=3\\
y_{2,1} & = & a_{1,2,1}b_{1}+a_{2,2,1}b_{2}=3\cdot1+4\cdot1=7\\
y_{1,2} & = & a_{1,1,2}b_{1}+a_{2,1,2}b_{2}=5\cdot1+6\cdot1=11\\
y_{2,2} & = & a_{1,2,2}b_{1}+a_{2,2,2}b_{2}=7\cdot1+8\cdot1=15
\end{eqnarray*}

\end_inset

In (Einstein) tensor notation
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The tensor notation is named after Einstein if want dispenses with the summation
 sign.
 The convention is that one is summing over the index that disappears from
 the resulting left hand side.
 See 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://en.wikipedia.org/wiki/Einstein_notation
\end_layout

\end_inset

.
\end_layout

\end_inset

, our operation is defined as 
\begin_inset Formula 
\begin{eqnarray*}
y_{j,k} & = & a_{i,j,k}b_{i}\\
 & = & \sum_{i}a_{i,j,k}b_{i}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsubsection
Matrix multiply along j
\end_layout

\begin_layout Standard
In exact analogy to above, we can assign b to a different (matching!) index
 of a -- in this case j.
 We want to do 
\begin_inset Formula 
\begin{eqnarray*}
y_{i,k} & = & \sum_{j}a_{i,j,k}b_{j}
\end{eqnarray*}

\end_inset

Thus, we obtain an i by k array:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<usage2>>=
\end_layout

\begin_layout Plain Layout

TI( a[i,j,k] * b[j], k + i)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Matrix multiply with array
\end_layout

\begin_layout Standard
Now we do the same with 2 dimensional array B.
 Much in the same way, we specify common indices, and give the index we
 wish to keep in the result to TI().
 In terms of tensor notation, we want to do 
\begin_inset Formula 
\begin{eqnarray*}
y_{k} & = & \sum_{i}\sum_{j}a_{i,j,k}B_{i,j}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<usage3>>=
\end_layout

\begin_layout Plain Layout

TI( a[i,j,k] * B[i,j], k)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Other Multidimensional Operations
\end_layout

\begin_layout Standard
As mentioned above, you are not restricted to do multiplication.
 In general, the functions will accept any binary operator.
 Let's see two examples.
 First, let's the a to the power of b along index k:
\begin_inset Formula 
\begin{eqnarray*}
y_{i,j} & = & \sum_{k}\left(a_{i,j,k}\right)^{b_{k}}
\end{eqnarray*}

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

<<other1>>=
\end_layout

\begin_layout Plain Layout

TI( a[i,j,k] ^ b[k], i + j ) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Secondly, let's sum up the cosine's of elements of a and B, keeping only
 dimension k:
\begin_inset Formula 
\begin{eqnarray*}
y_{k} & = & \sum_{i}\sum_{k}\cos\left(a_{i,j,k},B_{i,j}\right)
\end{eqnarray*}

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

<<other2>>=
\end_layout

\begin_layout Plain Layout

TI( cos(a[i,j,k],B[i,j]), k ) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Application: Evaluation of multidimensional B-splines
\end_layout

\begin_layout Standard
Disclaimer: This section is likely to be useful only if you have some prior
 knowledge about B-spline approximation.
 We will use observational data to approximate a multivariate function (or
 a 
\emph on
data generating process
\emph default
) on a space of tensor products of univariate B-splines.
 The function we want to approximte is defined as
\begin_inset Formula 
\begin{eqnarray*}
f:X\times Y\times Z & \mapsto & \mathbb{R}\\
f(x,y,z) & = & \left(x+y-5\right)^{2}+(z-5)^{2}
\end{eqnarray*}

\end_inset

and 
\begin_inset Formula $X,Y,Z\subset\mathbb{R}$
\end_inset

.
 We will get data on 
\begin_inset Formula $f$
\end_inset

 at a grid of points 
\begin_inset Formula $\left\{ x_{i},y_{j},z_{k}\right\} $
\end_inset

, and use this to compute an approximant to 
\begin_inset Formula $f$
\end_inset

.
 The coefficients obtained from the approximation procedure can in conjunction
 with the basis be used to approximate the function at an arbitrary set
 of points (in the approximation domain).
 We will use this to perform integration over one, and then 2 dimensions
 of this function with quadrature methods, i.e.
 we want to approximate
\begin_inset Formula 
\begin{eqnarray*}
E_{Y}\left[f(x,y,z)\right] & = & \int f(x,y,z)g(y)dy\\
E_{Z}\left[f(x,y,z)\right] & = & \int f(x,y,z)s(z)dz\\
E_{YZ}\left[f(x,y,z)\right] & = & \int f(x,y,z)s(z)g(y)dzdy
\end{eqnarray*}

\end_inset

where 
\begin_inset Formula $g,s$
\end_inset

 are the pdf of 
\begin_inset Formula $y,z$
\end_inset

 respectively.
 The advantages of RcppSimpleTensor are that we can write our code in a
 way which is very close to the mathematical expression, and we have a way
 to easily increase the number of dimensions with little additional cost.
 
\end_layout

\begin_layout Subsection
Data Setup
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<spline-setup,tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

library(splines)
\end_layout

\begin_layout Plain Layout

# select degree of splines 
\end_layout

\begin_layout Plain Layout

degree <- 3 
\end_layout

\begin_layout Plain Layout

# number of points in each dimension 
\end_layout

\begin_layout Plain Layout

num.x <- 10 
\end_layout

\begin_layout Plain Layout

num.y <- 8 
\end_layout

\begin_layout Plain Layout

num.z <- 4
\end_layout

\begin_layout Plain Layout

# make knot vectors.
 we want to clamp the curve at ends of domain, so we need "augmented" knot
 vectors 
\end_layout

\begin_layout Plain Layout

xknots <- c(rep(0,times=degree),seq(0,10,le=num.x),rep(10,times=degree))
 
\end_layout

\begin_layout Plain Layout

yknots <- c(rep(0,times=degree),seq(0,10,le=num.y),rep(10,times=degree))
 
\end_layout

\begin_layout Plain Layout

zknots <- c(rep(0,times=degree),seq(0,50,le=num.z),rep(50,times=degree))
\end_layout

\begin_layout Plain Layout

# select grid points where to evaluate the function 
\end_layout

\begin_layout Plain Layout

xdata <- as.array(seq(0,10,length=length(xknots)-degree-1)) 
\end_layout

\begin_layout Plain Layout

ydata <- as.array(seq(0,10,length=length(yknots)-degree-1)) 
\end_layout

\begin_layout Plain Layout

zdata <- as.array(seq(0,50,length=length(zknots)-degree-1))
\end_layout

\begin_layout Plain Layout

# design matrices 
\end_layout

\begin_layout Plain Layout

X <- splineDesign(knots=xknots,x=xdata) 
\end_layout

\begin_layout Plain Layout

Y <- splineDesign(knots=yknots,x=ydata) 
\end_layout

\begin_layout Plain Layout

Z <- splineDesign(knots=zknots,x=zdata)
\end_layout

\begin_layout Plain Layout

# define the function that will give us data (data generating process) 
\end_layout

\begin_layout Plain Layout

DGP <- function( x,y,z ) { return((x + y - 0.5)^2 + (z-0.5)^2) }
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Generate Data: Evaluate the function
\end_layout

\begin_layout Standard
We compare evaluation time of the 3-dimensional function with a mapply operation
 and with RcppSimpleTensor, as follows:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<evaluate,tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

data.grid <- expand.grid(x=xdata,y=ydata,z=zdata) 
\end_layout

\begin_layout Plain Layout

# traditional way: do a mapply over a grid:
\end_layout

\begin_layout Plain Layout

trad.time <- system.time(traditional <- array( with(data.grid, mapply(DGP,x,y,z)),
 dim=c(length(xdata),length(ydata),length(zdata))))
\end_layout

\begin_layout Plain Layout

# evaluate function with RcppSimpleTensor 
\end_layout

\begin_layout Plain Layout

# define a tensor function to calculate function values: 
\end_layout

\begin_layout Plain Layout

RcppVals <- tensorFunction( R[i,j,k] ~ (X[i] + Y[j] - 0.5)^2 + (Z[k] - 0.5)^2
 ) 
\end_layout

\begin_layout Plain Layout

# read: return array indexed by [i,j,k], defined as (x[i] + y[j] - 0.5)^2
 + (z[k]-0.5)^2
\end_layout

\begin_layout Plain Layout

Rcpp.time <- system.time( RcppArray <- RcppVals(xdata,ydata,zdata) ) 
\end_layout

\begin_layout Plain Layout

sum(abs(traditional - RcppArray))
\end_layout

\begin_layout Plain Layout

print(rbind(trad.time,Rcpp.time)) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Visualize the function
\end_layout

\begin_layout Standard
Just for orientation, let's plot the function at the highest and lowest
 value of variable z, respectively:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plotfun,par=TRUE,tidy=FALSE,echo=FALSE,fig.width=4,fig.height=4,out.width=0.45
\backslash
linewidth>>=
\end_layout

\begin_layout Plain Layout

zind <- 1:length(zdata); 
\end_layout

\begin_layout Plain Layout

persp(x=xdata,y=ydata,z=RcppArray[,,tail(zind,1)],ticktype="detailed",xlab="x",y
lab="y",zlab="value",theta=300,phi=30);
\end_layout

\begin_layout Plain Layout

persp(x=xdata,y=ydata,z=RcppArray[,,head(zind,1)],ticktype="detailed",xlab="x",y
lab="y",zlab="value",theta=300,phi=30);
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Compute Approximant on Grid
\end_layout

\begin_layout Standard
Now we obtain the approximating coefficients by solving the system 
\begin_inset Formula 
\[
y=bA
\]

\end_inset

where y are the function values at each grid point, b is our vector of coefficie
nts and A is the tensor product of X, Y and Z.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<get-coeffs>>=
\end_layout

\begin_layout Plain Layout

b <- solve(kronecker(Z,kronecker(Y,X)), as.vector(RcppArray))
\end_layout

\begin_layout Plain Layout

# put coefficients into a 3-dimensional array 
\end_layout

\begin_layout Plain Layout

bb <- array(b,dim=c(length(xdata),length(ydata),length(zdata)))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Use RcppSimpleTensor to Evaluate Spline
\end_layout

\begin_layout Standard
Next, we generate random data in the domain of our approximation, and evaluate
 the following expression, which is our approximant 
\begin_inset Formula $\hat{f}$
\end_inset

 at arbitrary data 
\begin_inset Formula $(x,y,z)$
\end_inset

:
\begin_inset Formula 
\[
\hat{f}(x,y,z)=\sum_{i}\sum_{j}\sum_{k}b_{i,j,k}X_{i}(x)Y_{j}(y)Z_{k}(z)
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval-spline-new,tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# new random data
\end_layout

\begin_layout Plain Layout

new_xdata <- sort(10 * runif( 20 ))
\end_layout

\begin_layout Plain Layout

new_ydata <- sort(10 * runif( 25 ))
\end_layout

\begin_layout Plain Layout

new_zdata <- sort(50*runif(19))
\end_layout

\begin_layout Plain Layout

# basis for new values 
\end_layout

\begin_layout Plain Layout

new_X <- splineDesign(knots=xknots,x=new_xdata) 
\end_layout

\begin_layout Plain Layout

new_Y <- splineDesign(knots=yknots,x=new_ydata) 
\end_layout

\begin_layout Plain Layout

new_Z <- splineDesign(knots=zknots,x=new_zdata)
\end_layout

\begin_layout Plain Layout

# define RcppSimpleTensor function 
\end_layout

\begin_layout Plain Layout

spline.eval <- tensorFunction(R[nx,ny,nz] ~ coeffs[mx,my,mz] * Xbase[nx,mx]
 * Ybase[ny,my] * Zbase[nz,mz])
\end_layout

\begin_layout Plain Layout

pred.vals <- spline.eval( bb, new_X, new_Y, new_Z )        
\end_layout

\begin_layout Plain Layout

# or simply with inline: 
\end_layout

\begin_layout Plain Layout

TIpred.vals <- TI( bb[m1,m2,m3] * new_X[n1,m1] * new_Y[n2,m2] * new_Z[n3,m3],
 n1+n2+n3)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's see how we are doing by plotting our approximant, again for the two
 most extreme values of z:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-new,par=TRUE,tidy=FALSE,echo=FALSE,fig.width=4,fig.height=4,out.width=0.45
\backslash
linewidth>>=
\end_layout

\begin_layout Plain Layout

zind <- 1:length(new_zdata);
\end_layout

\begin_layout Plain Layout

persp(x=new_xdata,y=new_ydata,z=pred.vals[,,head(zind,1)],ticktype="detailed",xla
b="new_x",ylab="new_y",zlab="approx",theta=300,phi=30) 
\end_layout

\begin_layout Plain Layout

persp(x=new_xdata,y=new_ydata,z=pred.vals[,,tail(zind,1)],ticktype="detailed",xla
b="new_x",ylab="new_y",zlab="approx",theta=300,phi=30)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Perform numerical Integration
\end_layout

\begin_layout Standard
Now we redefine z and y as normal, independent random variables, against
 which we want to integrate 
\begin_inset Formula $f$
\end_inset

.
 We recompute our approximation on a grid on this redefined space, and generate
 data on all integration nodes.
 Then we evaluate the integrals.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<int-setup,tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

library(statmod) 
\end_layout

\begin_layout Plain Layout

# obtain integration nodes
\end_layout

\begin_layout Plain Layout

num.z <- 50 
\end_layout

\begin_layout Plain Layout

int.z <- gauss.quad(n=num.z,kind="hermite")   
\end_layout

\begin_layout Plain Layout

num.y <- 40
\end_layout

\begin_layout Plain Layout

int.y <- gauss.quad(n=num.y,kind="hermite")
\end_layout

\begin_layout Plain Layout

# get knots on domain of nodes
\end_layout

\begin_layout Plain Layout

zknots<-c(rep(min(int.z$nodes),times=degree),
\end_layout

\begin_layout Plain Layout

seq(int.z$nodes[1],int.z$nodes[num.z],le=6),rep(max(int.z$nodes),times=degree))
 
\end_layout

\begin_layout Plain Layout

yknots<-c(rep(min(int.y$nodes),times=degree),
\end_layout

\begin_layout Plain Layout

seq(int.y$nodes[1],int.y$nodes[num.y],le=7),rep(max(int.y$nodes),times=degree))
\end_layout

\begin_layout Plain Layout

# make grid to compute approximant on
\end_layout

\begin_layout Plain Layout

ydata<-as.array(seq(int.y$nodes[1],int.y$nodes[num.y],length=length(yknots)-degree-1
)) 
\end_layout

\begin_layout Plain Layout

zdata <- as.array(seq(int.z$nodes[1],int.z$nodes[num.z],length=length(zknots)-degree
-1))
\end_layout

\begin_layout Plain Layout

# basis on approximation grid	
\end_layout

\begin_layout Plain Layout

Z <- splineDesign(knots=zknots,x=zdata) 
\end_layout

\begin_layout Plain Layout

Y <- splineDesign(knots=yknots,x=ydata) 
\end_layout

\begin_layout Plain Layout

# generate data 
\end_layout

\begin_layout Plain Layout

RcppArray <- RcppVals(xdata,ydata,zdata)
\end_layout

\begin_layout Plain Layout

# calculate spline coeffs 
\end_layout

\begin_layout Plain Layout

b <- solve(kronecker(Z,kronecker(Y,X)), as.vector(RcppArray)) 
\end_layout

\begin_layout Plain Layout

bb <- array(b,dim=c(length(xdata),length(ydata),length(zdata)))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next step is to obtain data on the finer grid of integration nodes, and
 to integrate.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<get-intdata,par=TRUE,tidy=FALSE,fig.width=4,fig.height=4,out.width=0.7
\backslash
linewidth>>=
\end_layout

\begin_layout Plain Layout

# calculate basis on integration nodes 
\end_layout

\begin_layout Plain Layout

Int.base.z <- splineDesign(knots=zknots,x=int.z$nodes) 
\end_layout

\begin_layout Plain Layout

Int.base.y <- splineDesign(knots=yknots,x=int.y$nodes) 
\end_layout

\begin_layout Plain Layout

Intdata <- spline.eval( bb, X, Int.base.y, Int.base.z )
\end_layout

\begin_layout Plain Layout

yweights <- int.y$weights 
\end_layout

\begin_layout Plain Layout

zweights <- int.z$weights
\end_layout

\begin_layout Plain Layout

#### integrate
\end_layout

\begin_layout Plain Layout

#i.e.
 weighted sum over corresponding dimensions 
\end_layout

\begin_layout Plain Layout

RcppIntFun <- tensorFunction( R[nx] ~ Data[nx,ny,nz] * yweight[ny] * zweight[nz]
 ) 
\end_layout

\begin_layout Plain Layout

Int.y.z <- RcppIntFun( Intdata, yweights, zweights )
\end_layout

\begin_layout Plain Layout

dim(Int.y.z)
\end_layout

\begin_layout Plain Layout

plot(xdata,Int.y.z,type="l")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If we want to integrate only one out of many dimensions, this is very easily
 accomplished with RcppSimpleTensor: just select the right dimensions and
 recompute:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<one-only,par=TRUE,tidy=FALSE,echo=FALSE,fig.width=4,fig.height=4,out.width=0.45
\backslash
linewidth>>=
\end_layout

\begin_layout Plain Layout

# integrate w.r.t.
 z only  
\end_layout

\begin_layout Plain Layout

Int.z <- TI( Intdata[nx,ny,nz] * zweights[nz], nx + ny) 
\end_layout

\begin_layout Plain Layout

dim(Int.z) 
\end_layout

\begin_layout Plain Layout

persp(x=xdata,y=int.y$nodes,z=Int.z,xlab="xdata",ylab="int.y$nodes",zlab="Value",th
eta=300,phi=30)
\end_layout

\begin_layout Plain Layout

# integrate w.r.t.
 y only  
\end_layout

\begin_layout Plain Layout

Int.y <- TI( Intdata[nx,ny,nz] * yweights[ny], nx + nz ) 
\end_layout

\begin_layout Plain Layout

persp(x=xdata,y=int.z$nodes,z=Int.y,xlab="xdata",ylab="int.z$nodes",zlab="Value",th
eta=300,phi=30)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_body
\end_document
